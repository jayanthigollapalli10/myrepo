import xml.etree.ElementTree as ET
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

# -----------------------------------------------------
# 1. Parse XML into Graph + Topics
# -----------------------------------------------------
def parse_xml(xml_text):
    tree = ET.fromstring(xml_text)
    graph = {}
    topics_map = {}

    for page in tree.findall('page'):
        title = page.find('title').text.strip()
        links = [l.text.strip() for l in page.findall('link')]
        topics = page.find('topics').text.strip().split(",") if page.find('topics') is not None else []

        graph[title] = links
        topics_map[title] = [t.strip() for t in topics]

    return graph, topics_map


# -----------------------------------------------------
# 2. Create Adjacency Matrix
# -----------------------------------------------------
def build_adj_matrix(graph):
    pages = list(graph.keys())
    idx = {p: i for i, p in enumerate(pages)}
    n = len(pages)
    M = np.zeros((n, n))

    for page, links in graph.items():
        j = idx[page]
        if links:
            prob = 1 / len(links)
            for link in links:
                if link in idx:
                    M[idx[link]][j] = prob
        else:
            M[:, j] = 1 / n   # dangling node

    return M, pages


# -----------------------------------------------------
# 3. Topic-Specific PageRank
# -----------------------------------------------------
def topic_specific_pagerank(M, pages, topics_map, topic, d=0.85, tol=1e-6, max_iter=100):
    n = len(pages)
    teleport = np.array([1 if topic in topics_map[p] else 0 for p in pages])

    if teleport.sum() == 0:  # no pages with that topic
        teleport = np.ones(n)

    teleport = teleport / teleport.sum()
    r = np.ones(n) / n

    for _ in range(max_iter):
        r_new = d * M @ r + (1 - d) * teleport
        if np.linalg.norm(r_new - r, 1) < tol:
            break
        r = r_new

    return dict(zip(pages, r))


# -----------------------------------------------------
# 4. Draw Graph with Highlighted Topic Nodes
# -----------------------------------------------------
def draw_web_graph(graph, topics_map, topic):
    G = nx.DiGraph()

    for p, links in graph.items():
        for l in links:
            G.add_edge(p, l)

    colors = ["lightgreen" if topic in topics_map[n] else "skyblue" for n in G.nodes()]

    plt.figure(figsize=(6, 4))
    pos = nx.spring_layout(G, seed=42)
    nx.draw(G, pos, with_labels=True, node_color=colors, node_size=1500,
            font_size=10, arrowsize=15, edge_color="gray")
    plt.title(f"Web Graph (Highlighted Topic: {topic})")
    plt.show()


# -----------------------------------------------------
# 5. MAIN PROGRAM
# -----------------------------------------------------
xml_text = '''
<web>
    <page>
        <title>PageA</title>
        <link>PageB</link>
        <link>PageC</link>
        <topics>science,education</topics>
    </page>

    <page>
        <title>PageB</title>
        <link>PageC</link>
        <topics>science</topics>
    </page>

    <page>
        <title>PageC</title>
        <topics>sports</topics>
    </page>
</web>
'''

# Parse the web structure
graph, topics_map = parse_xml(xml_text)
M, pages = build_adj_matrix(graph)

# Draw graph
topic = "science"
draw_web_graph(graph, topics_map, topic)

# Compute Topic-Specific PageRank
ranks = topic_specific_pagerank(M, pages, topics_map, topic)

print("\nTopic-Specific PageRank (Topic: science):")
for page, score in sorted(ranks.items(), key=lambda x: -x[1]):
    print(f"{page}: {score:.4f}")


Rank Output Example:
Topic-Specific PageRank (Topic: science):
PageC: 0.4849
PageB: 0.3027
PageA: 0.2124


